# Set filter values for PoverA
# Smallest sample size per treatment is 3, so 3/9 (9 samples) is 0.33 (rounded to 2 decimal places)
# This means that 3 out of 9 (0.33) samples need to have counts over 10.
# So P=33 percent of the samples have counts over A=10.
#there's something up with this code :( )
filt <- filterfun(pOverA(0.33, 10))
# Create filter for the counts data
gfilt <- genefilter(gcount, filt)
treatmentinfo <- read_csv("5-Mcap-SampleInfo.csv")
#gcount <- as.data.frame(read.csv("E:/Users/amurgueitio/Documents/Multistage_omics/R scripts/M. capitata/New_genome/fixed_gff/Mcap_transcript_count_matrix.csv", row.names="gene_id"), colClasses = double, header=TRUE)
gcount <- as.data.frame(read.csv("Mcap_transcript_count_matrix.csv", row.names="gene_id"), colClasses = double, header=TRUE)
# Set filter values for PoverA
# Smallest sample size per treatment is 3, so 3/9 (9 samples) is 0.33 (rounded to 2 decimal places)
# This means that 3 out of 9 (0.33) samples need to have counts over 10.
# So P=33 percent of the samples have counts over A=10.
#there's something up with this code :( )
filt <- filterfun(pOverA(0.33, 10))
# Create filter for the counts data
gfilt <- genefilter(gcount, filt)
# Identify genes to keep by count filter
gkeep <- gcount[gfilt,]
# Identify gene lists
gn.keep <- rownames(gkeep)
#gene count data filtered in PoverA, P percent of the samples have counts over A
gcount_filt <- as.data.frame(gcount[which(rownames(gcount) %in% gn.keep),])
#How many rows do we have before and after filtering?
nrow(gcount) #Before 54384
nrow(gcount_filt) #After 25741
#Merge Set group as a factor.
treatmentinfo$timepoint <- factor(treatmentinfo$timepoint, levels = c("I","II","III"))
# Creating an alignment rate table
alignment_table <- tribble(
~SampleID, ~SRR, ~AlignRate,
"AH1", "SRR14864072", 73.0,
"AH2", "SRR14864071", 80.8,
"AH3", "SRR14864070", 82.1,
"AH4", "SRR14864069", 79.9,
"AH5", "SRR14864068", 71.9,
"AH6", "SRR14864067", 73.0,
"AH7", "SRR14864066", 47.3,
"AH8", "SRR14864065", 65.0,
"AH9", "SRR14864064", 63.4
)
View(treatmentinfo)
# Merge alignment rates into your existing sample metadata
treatmentinfo <- treatmentinfo %>%
left_join(alignment_table, by = c("sampleID" = "SampleID"))
#Correction based on TINS
# Load TIN data
tin_data <- read.table("multiqc_tin.txt", header = TRUE)
# Rename column for clarity
colnames(tin_data) <- c("SRR", "TIN")
tin_data <- left_join(tin_data, alignment_table, by = "SRR")  # Adds SampleID column
treatmentinfo$TIN_scaled <- scale(treatmentinfo$TIN)
tin_data <- left_join(tin_data, alignment_table, by = "SRR")  # Adds SampleID and AlignRate
treatmentinfo$TIN_scaled <- scale(treatmentinfo$TIN)
View(treatmentinfo)
setwd("C:/Users/amurg/OneDrive/Documentos/GitHub/Multistage_omics/WGCNA/M. capitata/Inputs")
#Data--------------------------------------------------------------------------------------
#treatmentinfo <- read_csv("E:/Users/amurgueitio/Documents/Multistage_omics/R scripts/M. capitata/New_genome/fixed_gff/5-Mcap-SampleInfo.csv")
library(readr)
treatmentinfo <- read_csv("5-Mcap-SampleInfo.csv")
#gcount <- as.data.frame(read.csv("E:/Users/amurgueitio/Documents/Multistage_omics/R scripts/M. capitata/New_genome/fixed_gff/Mcap_transcript_count_matrix.csv", row.names="gene_id"), colClasses = double, header=TRUE)
gcount <- as.data.frame(read.csv("Mcap_transcript_count_matrix.csv", row.names="gene_id"), colClasses = double, header=TRUE)
#Quality filter gene counts-----------------------------------------------------------
# Set filter values for PoverA
# Smallest sample size per treatment is 3, so 3/9 (9 samples) is 0.33 (rounded to 2 decimal places)
# This means that 3 out of 9 (0.33) samples need to have counts over 10.
# So P=33 percent of the samples have counts over A=10.
#there's something up with this code :( )
filt <- filterfun(pOverA(0.33, 10))
# Create filter for the counts data
gfilt <- genefilter(gcount, filt)
# Identify genes to keep by count filter
gkeep <- gcount[gfilt,]
# Identify gene lists
gn.keep <- rownames(gkeep)
#gene count data filtered in PoverA, P percent of the samples have counts over A
gcount_filt <- as.data.frame(gcount[which(rownames(gcount) %in% gn.keep),])
#How many rows do we have before and after filtering?
nrow(gcount) #Before 54384
nrow(gcount_filt) #After 25741
# Normalize our read counts using VST-normalization in DESeq2
# Construct the DESeq2 dataset
#Merge Set group as a factor.
treatmentinfo$timepoint <- factor(treatmentinfo$timepoint, levels = c("I","II","III"))
#Create a DESeqDataSet design from gene count matrix and labels. Here we set the design to look at
#any differences in gene expression across samples attributed to life stage
View(treatmentinfo)
#gene count data filtered in PoverA, P percent of the samples have counts over A
gcount_filt <- as.data.frame(gcount[which(rownames(gcount) %in% gn.keep),])
#How many rows do we have before and after filtering?
nrow(gcount) #Before 54384
nrow(gcount_filt) #After 25741
#Merge Set group as a factor.
treatmentinfo$timepoint <- factor(treatmentinfo$timepoint, levels = c("I","II","III"))
# Create alignment table
alignment_table <- tribble(
~SampleID, ~SRR, ~AlignRate,
"AH1", "SRR14864072", 73.0,
"AH2", "SRR14864071", 80.8,
"AH3", "SRR14864070", 82.1,
"AH4", "SRR14864069", 79.9,
"AH5", "SRR14864068", 71.9,
"AH6", "SRR14864067", 73.0,
"AH7", "SRR14864066", 47.3,
"AH8", "SRR14864065", 65.0,
"AH9", "SRR14864064", 63.4
)
# Merge AlignRate into treatmentinfo
treatmentinfo <- treatmentinfo %>%
left_join(alignment_table, by = c("sampleID" = "SampleID"))
# Load TIN data
tin_data <- read.table("multiqc_tin.txt", header = TRUE)
# Rename columns
colnames(tin_data) <- c("SRR", "TIN")
# Merge TIN with alignment_table to get SampleID
tin_data <- tin_data %>%
left_join(alignment_table %>% select(SRR, SampleID), by = "SRR")
# Now merge TIN into treatmentinfo
treatmentinfo <- treatmentinfo %>%
left_join(tin_data %>% select(SampleID, TIN), by = c("sampleID" = "SampleID"))
# Now scale TIN
treatmentinfo$TIN_scaled <- scale(treatmentinfo$TIN)
View(treatmentinfo)
View(treatmentinfo)
rna_quality <- tribble(
~SampleID, ~TotalRNA, ~RIN, ~RNA_260_230, ~RNA_260_280,
"AH1", 28.7, 8.4, 0.3, 1.88,
"AH2", 45.4, 9.2, 0.37, 2.06,
"AH3", 27.8, 8.5, 0.9, 1.75,
"AH4", 32.3, 8.6, 1.16, 1.85,
"AH5", 32.3, 8.9, 0.65, 1.90,
"AH6", 30.8, 8.7, 1.18, 1.87,
"AH7", 26.4, 6.1, 1.05, 1.87,
"AH8", 56.3, 7.4, 1.28, 1.96,
"AH9", 41.8, 6.8, 0.22, 1.99
)
treatmentinfo <- treatmentinfo %>%
left_join(rna_quality, by = c("sampleID" = "SampleID"))
treatmentinfo <- treatmentinfo %>%
mutate(
RIN_scaled = scale(RIN),
RNA_260_230_scaled = scale(RNA_260_230),
RNA_260_280_scaled = scale(RNA_260_280),
TotalRNA_scaled = scale(TotalRNA)
)
treatmentinfo <- treatmentinfo %>%
mutate(AlignRate_scaled = scale(AlignRate))
covariates <- treatmentinfo %>%
select(RIN_scaled, RNA_260_230_scaled, RNA_260_280_scaled,
TotalRNA_scaled, TIN_scaled, AlignRate_scaled)
cor_matrix <- cor(covariates, use = "complete.obs")
round(cor_matrix, 2)
library(corrplot)
corrplot(cor_matrix, method = "color", type = "upper", tl.col = "black")
library(car)
linear_model <- lm(1 ~ ., data = covariates)
library(car)
linear_model <- lm(1 ~ ., data = covariates)
vif(linear_model)
View(covariates)
covariates <- treatmentinfo %>%
select(RIN_scaled, TIN_scaled, AlignRate_scaled,
RNA_260_230_scaled, RNA_260_280_scaled, TotalRNA_scaled) %>%
filter(complete.cases(.))  # Ensures all columns have same number of rows
View(covariates)
sapply(covariates, length)
linear_model <- lm(rep(1, nrow(covariates)) ~ ., data = covariates)
vif(linear_model)
covariates_raw <- treatmentinfo %>%
select(RIN, TIN, AlignRate, RNA_260_230, RNA_260_280, TotalRNA) %>%
filter(complete.cases(.))
linear_model_raw <- lm(rep(1, nrow(covariates_raw)) ~ ., data = covariates_raw)
vif(linear_model_raw)
treatmentinfo %>%
select(TIN_scaled, RNA_260_230_scaled, RNA_260_280_scaled, TotalRNA_scaled) %>%
cor(use = "complete.obs") %>%
round(2)
library(variancePartition)
View(treatmentinfo)
library(variancePartition)
library(edgeR)
library(limma)
# Prepare metadata
metadata <- treatmentinfo  # or whatever your data frame is named
# Ensure sampleIDs in metadata match colnames in expression matrix
all(metadata$sampleID %in% colnames(exprs))  # should return TRUE
View(metadata)
all(colnames(gcount_filt) %in% treatmentinfo$sampleID)  # should return TRUE
# Reorder metadata to match expression matrix
treatmentinfo <- treatmentinfo[match(colnames(gcount_filt), treatmentinfo$sampleID), ]
# Create DGEList
dge <- DGEList(counts = gcount_filt)
# Filter again just to be safe (optional but good practice)
keep <- filterByExpr(dge, design = model.matrix(form, treatmentinfo))
library(corrplot)
# Reorder metadata to match expression matrix
treatmentinfo <- treatmentinfo[match(colnames(gcount_filt), treatmentinfo$sampleID), ]
# Create DGEList
dge <- DGEList(counts = gcount_filt)
# Filter again just to be safe (optional but good practice)
keep <- filterByExpr(dge, design = model.matrix(form, treatmentinfo))
form <- ~ timepoint + TIN_scaled + RNA_260_230_scaled + RNA_260_280_scaled + TotalRNA_scaled
# Create DGEList
dge <- DGEList(counts = gcount_filt)
# Filter again just to be safe (optional but good practice)
keep <- filterByExpr(dge, design = model.matrix(form, treatmentinfo))
dge <- dge[keep, , keep.lib.sizes = FALSE]
# Normalize
dge <- calcNormFactors(dge)
# Voom transformation
vobj <- voom(dge, design = model.matrix(form, treatmentinfo), plot = TRUE)
# Fit the dream model
fit <- dream(vobj, form, treatmentinfo)
# Extract variance fractions
varPart <- fitExtractVarPartModel(fit, form, treatmentinfo)
# Make sure sample names are matched
rownames(treatmentinfo) <- treatmentinfo$sampleID
# Make sure sample names are matched
treatmentinfo <- as.data.frame(treatmentinfo)
rownames(treatmentinfo) <- treatmentinfo$sampleID
treatmentinfo <- treatmentinfo[colnames(gcount_filt), ]
# Create DGEList
dge <- DGEList(counts = gcount_filt)
# Filter low-expressed genes
form <- ~ timepoint + TIN_scaled + RNA_260_230_scaled + RNA_260_280_scaled + TotalRNA_scaled
keep <- filterByExpr(dge, design = model.matrix(form, treatmentinfo))
dge <- dge[keep, , keep.lib.sizes = FALSE]
# Normalize
dge <- calcNormFactors(dge)
# voom transform
vobj <- voom(dge, design = model.matrix(form, treatmentinfo), plot = TRUE)
# Run dream
fit <- dream(vobj, form, treatmentinfo)
# Check fit object class
class(fit)  # should be "Dream" not "MArrayLM"
str(vobj)
# Run dream
fit <- variancePartition::dream(vobj, design, treatmentinfo)
class(fit)  # should now be "Dream"
# Run dream
fit <- variancePartition::dream(vobj, design, treatmentinfo)
all(colnames(gcount_filt) %in% treatmentinfo$sampleID)  # should return TRUE
# 1. Define model formula
form <- ~ timepoint + TIN_scaled + RNA_260_230_scaled + RNA_260_280_scaled + TotalRNA_scaled
# 2. Set sample names as rownames
treatmentinfo <- as.data.frame(treatmentinfo)
rownames(treatmentinfo) <- treatmentinfo$sampleID
# 3. Build design matrix
design_matrix <- model.matrix(form, data = treatmentinfo)
# 4. Filter and normalize gene counts
dge <- DGEList(counts = gcount_filt)
keep <- filterByExpr(dge, design = design_matrix)
dge <- dge[keep,, keep.lib.sizes = FALSE]
dge <- calcNormFactors(dge)
# 5. Voom transformation
vobj <- voom(dge, design = design_matrix, plot = TRUE)
# 6. Fit variancePartition model
fit <- dream(vobj, form, treatmentinfo)
# 7. Extract and plot variance fractions
vp <- fitExtractVarPartModel(fit)
# 6. Fit variancePartition model
fit <- variancePartition::dream(vobj, formula = form, data = treatmentinfo)
# 7. Extract and plot variance fractions
vp <- fitExtractVarPartModel(fit)
# 6. Fit variancePartition model
fit <- variancePartition::dream(vobj, formula = form, data = treatmentinfo)
# 7. Extract and plot variance fractions
vp <- fitExtractVarPartModel(fit)
# 1. Create design formula
form <- ~ timepoint + TIN_scaled + RNA_260_280_scaled
# 2. Create design matrix
design <- model.matrix(form, data = treatmentinfo)
# 3. Create DGEList
library(edgeR)
dge <- DGEList(counts = gcount_filt)
# 4. Filter lowly expressed genes (if not already done)
keep <- filterByExpr(dge, design)
dge <- dge[keep, ]
# 5. Normalize
dge <- calcNormFactors(dge)
# 6. Apply voom WITH PRECISION WEIGHTS
library(variancePartition)
vobj <- voomWithDreamWeights(dge, design, data = treatmentinfo)
vobj <- voomWithDreamWeights(dge, formula = form, data = treatmentinfo)
# 7. Fit the dream model
fit <- dream(vobj, formula = form, data = treatmentinfo)
# 8. Extract variance fractions
vp <- fitExtractVarPartModel(fit)
# 1. Define the formula
form <- ~ timepoint + TIN_scaled + RNA_260_230_scaled + RNA_260_280_scaled + TotalRNA_scaled
# 2. Apply voom with dream weights (this sets up everything internally)
vobj <- voomWithDreamWeights(dge, formula = form, data = treatmentinfo)
# 3. Fit dream model: use design already embedded in vobj (do NOT pass formula again)
fit <- dream(vobj, data = treatmentinfo)
# 4. Extract variance fractions
vp <- fitExtractVarPartModel(fit)
# Sample name consistency
colnames(gcount_filt)
rownames(treatmentinfo)
# Should return TRUE:
all(colnames(gcount_filt) == rownames(treatmentinfo))
# Step 1: Define model formula
form <- ~ timepoint + TIN_scaled + RNA_260_230_scaled + RNA_260_280_scaled + TotalRNA_scaled
# Step 2: Ensure sample names match between gcount and metadata
stopifnot(all(colnames(gcount_filt) == treatmentinfo$sampleID))  # Throws error if mismatch
rownames(treatmentinfo) <- treatmentinfo$sampleID  # Needed for dream()
# Step 3: Create DGEList
dge <- DGEList(counts = gcount_filt)
dge <- calcNormFactors(dge)
# Step 4: Filter low-expression genes
keep <- filterByExpr(dge, design = model.matrix(form, data = treatmentinfo))
dge <- dge[keep, ]
# Step 5: voom with weights
vobj <- voomWithDreamWeights(dge, formula = form, data = treatmentinfo)
# Step 6: Fit dream model
fit <- dream(vobj, formula = form, data = treatmentinfo)
# Step 7: Extract variance fractions
vp <- fitExtractVarPartModel(fit)
# Step 8: Plot variance fractions
plotVarPart(vp)
class(fit)
str(vobj$weights)  # Should be a matrix of same dimensions as gcount_filt
# Step 1: Define model formula
form <- ~ (1|timepoint) + (1|TIN_scaled) + (1|RNA_260_230_scaled) +
(1|RNA_260_280_scaled) + (1|TotalRNA_scaled)
# Step 2: Ensure sample names match between gcount and metadata
stopifnot(all(colnames(gcount_filt) == treatmentinfo$sampleID))  # Throws error if mismatch
rownames(treatmentinfo) <- treatmentinfo$sampleID  # Needed for dream()
# Step 3: Create DGEList
dge <- DGEList(counts = gcount_filt)
dge <- calcNormFactors(dge)
# Step 4: Filter low-expression genes
keep <- filterByExpr(dge, design = model.matrix(form, data = treatmentinfo))
# Set rownames for treatmentinfo
rownames(treatmentinfo) <- treatmentinfo$sampleID
# Filter low-expression genes (use fixed-effects formula)
form_fixed <- ~ timepoint + TIN_scaled + RNA_260_230_scaled + RNA_260_280_scaled + TotalRNA_scaled
dge <- DGEList(counts = gcount)
dge <- calcNormFactors(dge)
keep <- filterByExpr(dge, design = model.matrix(form_fixed, data = treatmentinfo))
dge <- dge[keep, ]
# Define random-effects formula for variance partitioning
form <- ~ (1|timepoint) + (1|TIN_scaled) + (1|RNA_260_230_scaled) +
(1|RNA_260_280_scaled) + (1|TotalRNA_scaled)
# Apply voom with dream weights
vobj <- voomWithDreamWeights(dge, formula = form, data = treatmentinfo)
library(GenomicFeatures)
# Load GFF3 and build TxDb
txdb <- makeTxDbFromGFF("Montipora_capitata_HIv3.genes.gff3", format = "gff3")
# Get exon ranges grouped by gene
exons_by_gene <- exonsBy(txdb, by = "gene")
# Sum of non-overlapping exon widths per gene
gene_lengths <- sum(width(reduce(exons_by_gene)))
View(exons_by_gene)
View(exons_by_gene)
library(GenomicFeatures)
library(rtracklayer)
gff <- import("Montipora_capitata_HIv3.genes.gff3")
table(gff$type)
# Load GFF3 and build TxDb
txdb <- makeTxDbFromGFF("Montipora_capitata_HIv3.genes.gff3", format = "gff3")
# Get exons grouped by transcript (tx)
exons_by_tx <- exonsBy(txdb, by = "tx")
# Non-overlapping exon lengths per transcript
tx_lengths <- sum(width(reduce(exons_by_tx)))
# Convert to data frame
tx_length_df <- data.frame(
transcript_id = names(tx_lengths),
length = as.numeric(tx_lengths)
)
# Step 2: Get exons grouped by transcript
exons_by_tx <- exonsBy(txdb, by = "tx")
View(exons_by_tx)
# Step 3: Reduce overlapping exons per transcript
reduced_exons <- reduce(exons_by_tx)
reduced_exons <- GenomicRanges::reduce(exons_by_tx)
# Step 3: Reduce overlapping exons per transcript
reduced_exons <- reduce(exons_by_tx)
reduced_exons <- GenomicRanges::reduce(exons_by_tx)
tx_lengths <- sum(width(reduced_exons))
tx_length_df <- data.frame(
transcript_id = names(tx_lengths),
length = as.numeric(tx_lengths)
)
View(tx_length_df)
head(rownames(gcount_filt))
View(tx_length_df)
# Path to your GFF3 file
gff_path <- "Montipora_capitata_HIv3.genes.gff3"
# Import GFF for ID mapping
gff <- import(gff_path)
gff <- import("Montipora_capitata_HIv3.genes.gff3")
# Create TxDb object from GFF
txdb <- makeTxDbFromGFF(gff_path, format = "gff3")
gff <- import("Montipora_capitata_HIv3.genes.gff3")
table(gff$type)
# Load GFF3 and build TxDb
txdb <- makeTxDbFromGFF("Montipora_capitata_HIv3.genes.gff3", format = "gff3")
# Step 2: Get exons grouped by transcript
exons_by_tx <- exonsBy(txdb, by = "tx")
reduced_exons <- GenomicRanges::reduce(exons_by_tx)
tx_lengths <- sum(width(reduced_exons))
tx_length_df <- data.frame(
transcript_id = names(tx_lengths),
length = as.numeric(tx_lengths)
)
head(rownames(gcount_filt))
# Step 2: Get exons grouped by transcript
exons_by_tx <- exonsBy(txdb, by = "tx")
reduced_exons <- GenomicRanges::reduce(exons_by_tx)
tx_lengths <- sum(width(reduced_exons))
# Get transcript features from GFF
transcripts <- subset(gff, type == "transcript")
# Extract real transcript IDs from attributes field
transcripts$transcript_id <- str_match(transcripts$attributes, "ID=([^;]+)")[,2]
head(transcripts$attributes)
colnames(mcols(transcripts))
View(transcripts)
#[1] "source" "type"   "score"  "phase"  "ID"     "Parent"
transcripts$transcript_id <- transcripts$ID
txdb_ids <- names(tx_lengths)
# Build internal ID (matching TxDb ordering)
transcripts$txdb_id <- as.character(seq_len(nrow(transcripts)))
#[1] "source" "type"   "score"  "phase"  "ID"     "Parent"
transcripts$transcript_id <- transcripts$ID
txdb_ids <- names(tx_lengths)
# Build internal ID (matching TxDb ordering)
transcripts$txdb_id <- as.character(seq_len(nrow(transcripts)))
# Add txdb-style internal IDs (for matching tx_lengths)
transcripts$txdb_id <- as.character(seq_len(length(transcripts)))
# tx_lengths from earlier: named vector from exonsBy(txdb, by = "tx")
txdb_ids <- names(tx_lengths)
# Build transcript ID mapping
transcript_map <- data.frame(
txdb_id = transcripts$txdb_id,
transcript_id = transcripts$transcript_id
)
# Combine lengths with transcript IDs
tx_length_df <- data.frame(
txdb_id = txdb_ids,
length = as.numeric(tx_lengths)
)
# Merge the two
length_df <- merge(tx_length_df, transcript_map, by = "txdb_id")
# Final clean length table
length_df <- length_df[, c("transcript_id", "length")]
View(length_df)
exons_tx <- exons_by_tx[["1"]]  # Or whatever the txdb ID is for that transcript
exons_tx
grep "Parent=Montipora_capitata_HIv3___RNAseq.g37162.t1" Montipora_capitata_HIv3.genes.gff3
# Get reduced ranges for that transcript
reduced_exons_tx <- GenomicRanges::reduce(exons_tx)
# Check them
reduced_exons_tx
# Calculate total width
sum(width(reduced_exons_tx))
length_vector <- setNames(length_df$length, length_df$transcript_id)
matched_lengths <- length_vector[rownames(gcount_filt)]
# Optional: check for any missing IDs
sum(is.na(matched_lengths))  # Should be 0 ideally
counts_to_tpm <- function(counts, lengths) {
rate <- counts / lengths
tpm <- t(t(rate) / colSums(rate)) * 1e6
return(tpm)
}
tpm_matrix <- counts_to_tpm(gcount_filt, matched_lengths)
log_tpm <- log2(tpm_matrix + 1)
# Calculate variance for each gene/transcript across samples
gene_vars <- apply(log_tpm, 1, var)
# Select top 500 (or 1000, or 2000)
top_genes <- head(order(gene_vars, decreasing = TRUE), 25741)
# Subset log_tpm
top_log_tpm <- log_tpm[top_genes, ]
# Transpose for PCA (samples as rows)
pca_res <- prcomp(t(top_log_tpm), scale. = TRUE)
pca_df <- as.data.frame(pca_res$x)
pca_df$sampleID <- rownames(pca_df)
# Join metadata
library(dplyr)
pca_df <- left_join(pca_df, treatmentinfo, by = "sampleID")
# Calculate % variance
percent_var <- round(100 * summary(pca_res)$importance[2, 1:2], 1)
library(ggplot2)
ggplot(pca_df, aes(PC1, PC2, color = timepoint, shape = timepoint)) +
geom_point(size = 5) +
xlab(paste0("PC1: ", percent_var[1], "% variance")) +
ylab(paste0("PC2: ", percent_var[2], "% variance")) +
coord_fixed() +
theme_classic() +
ggtitle("PCA on log2(TPM + 1)")
pca_df <- left_join(pca_df, treatmentinfo, by = "sampleID")
library(ggplot2)
ggplot(pca_df, aes(PC1, PC2, color = timepoint, shape = timepoint)) +
geom_point(size = 5) +
xlab(paste0("PC1: ", round(summary(tpm_pca)$importance[2,1] * 100, 1), "% variance")) +
ylab(paste0("PC2: ", round(summary(tpm_pca)$importance[2,2] * 100, 1), "% variance")) +
theme_classic() +
ggtitle("PCA on TPM (log2(TPM + 1))")
tpm_pca <- prcomp(t(log_tpm), scale. = TRUE)
pca_df <- as.data.frame(tpm_pca$x)
pca_df$sampleID <- rownames(pca_df)
library(dplyr)
pca_df <- left_join(pca_df, treatmentinfo, by = "sampleID")
library(ggplot2)
ggplot(pca_df, aes(PC1, PC2, color = timepoint, shape = timepoint)) +
geom_point(size = 5) +
xlab(paste0("PC1: ", round(summary(tpm_pca)$importance[2,1] * 100, 1), "% variance")) +
ylab(paste0("PC2: ", round(summary(tpm_pca)$importance[2,2] * 100, 1), "% variance")) +
theme_classic() +
ggtitle("PCA on TPM (log2(TPM + 1))")
